# Мета уроку – ознайомитися з хуками у реакті, 
їх призначенням та функціоналом. Навчитися використовувати хук стану використаннядержави на практиці. Розібрати способи зміни стану хука useState при роботі з масивами в якості значень. Вони дозволяють вам виводити логіку з компонентів для повторного використання та тестування. Зокрема, з використанням хуків, таких як useState, ви можете зручно керувати станом компонентів. Вбудовані хуки React

Хуки дозволяють використовувати різні функції React із ваших компонентів. Ви можете використовувати вбудовані хуки або комбінувати їх для створення власних. На цій сторінці перераховані всі вбудовані хуки в React. Державні гачки

Стан дозволяє компоненту «запам'ятовувати» інформацію, наприклад, введену користувачем інформацію. Наприклад, компонент форми може використовувати стан для збереження вхідного значення, тоді як компонент галереї зображень може використовувати стан для збереження індексу вибраного зображення.

## Щоб додати стан до компонента, скористайтесь одним із цих хуків:

**useState** оголошує змінну стану, яку можна обновити безпосередньо. 
**useReducer** оголошує змінну стану з логікою оновлення всередині функції редуктора. 
**function ImageGallery() { const [index, setIndex] = useState(0)**; 
// ... 
## Хуки контексту 
**Контекст дозволяє компоненту отримувати інформацію від віддалених батьків, не передаючи її як атрибути. Наприклад, компонент верхнього рівня вашої програми може передавати поточну тему інтерфейсу користувача всім компонентам нижче, незалежно від глибини**.

**useContext** читає контекст і підписується на нього. 
**function Button() { const theme = useContext(ThemeContext)**; 
// ... 
## Реферальні крючки 
Посилання дозволяють компоненту зберігати деяку інформацію, яка не використовується для відтворення, наприклад узел DOM або ідентифікатор часу очікування. На відміну від стану, оновлення посилання не відтворює повторно ваш компонент. 
**Refs** — це аварійний люк із парадигми React. Вони корисні, коли вам потрібно працювати із системами, не пов'язаними з React, такими як вбудовані API браузери.

**useRef** заявляє вих. У ньому можна зберігати будь-яке значення, але найчастіше воно використовується для зберігання вузла DOM.
useImperativeHandleдає можливість налаштувати посилання, що відображається вашим компонентом. Це рідко використовується.
**function Form() {
 const inputRef = useRef(null)**;
 // ...
 ### Хуки ефектів
 Ефекти дозволяють компоненту підключатися до зовнішніх систем та синхронізуватися з ними. Це включає роботу з мережею, DOM браузера, анімацією, віджетами, написаними з використанням іншої бібліотеки інтерфейсу користувача, та іншим кодом, не пов'язаним із React.

 **useEffect** підключає компонент до зовнішньої системи.
 **function ChatRoom({ roomId }) {
 useEffect(() => {
 const connection = createConnection(roomId);
 connection.connect();
 return() => connection.disconnect();
 }, [roomId])**;
 // ...
 ### Ефекти — це «аварійний люк» із парадигми React. 
 Не використовуйте Effects для організації потоку даних програми. Якщо ви не взаємодієте із зовнішньою системою, вам може не знадобитися ефект.

 Є два рідко використовувані варіанти використанняЕфект з різницею в годині:

 useLayoutEffectспрацьовує перед тим, як браузер перефарбує екран. Виміряти макет можна тут.
 useInsertionEffectзапускається до того, як React внесе зміни до DOM. Бібліотеки можуть вставляти сюди динамічний CSS.
 ### Хуки продуктивності
 Поширеним способом оптимізації продуктивності повторного рендерингу є пропуск непотрібної роботи. Наприклад, ви можете покарати React повторно використовувати кешування обчислення або пропустити повторну візуалізацію, якщо дані не змінилися з часу попередньої візуалізації.

 ### Щоб пропустити обчислення та непотрібне повторне рендеринг, скористайтесь одним із цих хуків:

 useMemo дозволяє кешувати результат дорогого обчислення.
 useCallback дозволяє кешувати визначення функції перед передачею його оптимізованому компоненту.
 **function TodoList({ todos, tab, theme }) {
 const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab])**;
 // ...
 }
